/*
Hypatia: A realtime malware scanner for Android
Copyright (c) 2024 Divested Computing Group

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
package us.spotco.malwarescanner;

import android.accessibilityservice.AccessibilityService;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.content.Context;
import android.os.Build;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;

import java.util.Random;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class LinkScannerService extends AccessibilityService {

    private static final String hostnameRegex = "^((?!-)[A-Za-z0-9-]{1,63}(?<!-)\\.)+[A-Za-z]{2,6}$"; //Credit: http://www.mkyong.com/regular-expressions/domain-name-regular-expression-example/
    private static final Pattern hostnamePattern = Pattern.compile(hostnameRegex);
    private static final ConcurrentSkipListMap<String, Long> scannedPackages = new ConcurrentSkipListMap<>();
    private static final ConcurrentSkipListMap<String, Thread> scannerThreads = new ConcurrentSkipListMap<>();

    private static final ConcurrentSkipListSet<Integer> scannedText = new ConcurrentSkipListSet<>();
    private static final ConcurrentSkipListSet<String> scannedDomains = new ConcurrentSkipListSet<>();
    private NotificationManager notificationManager = null;

    @Override
    public void onServiceConnected() {
        notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel detectionChannel = new NotificationChannel("DETECTION", getString(R.string.lblNotificationMalwareDetectionTitle), NotificationManager.IMPORTANCE_HIGH);
            detectionChannel.setDescription(getString(R.string.lblNotificationMalwareDetectionDescription));
            notificationManager.createNotificationChannel(detectionChannel);
        }
    }

    @Override
    public void onAccessibilityEvent(AccessibilityEvent event) {
        if (Database.isDomainDatabaseLoaded()) {
            boolean shouldScanView = true;
            String packageName = (String) event.getPackageName();
            if (event.getSource() != null) {
                packageName += event.getSource().getClassName();
            }
            if (scannedPackages.containsKey(packageName)) {
                if ((System.currentTimeMillis() - scannedPackages.get(packageName)) < 1000) {
                    shouldScanView = false;
                }
            }
            if (shouldScanView) {
                if (scannerThreads.containsKey(packageName)) {
                    Thread oldThread = scannerThreads.get(packageName);
                    if (oldThread != null) {
                        if (oldThread.isAlive()) {
                            shouldScanView = false;
                        } else {
                            scannerThreads.remove(packageName);
                        }
                    }
                }
            }
            if (shouldScanView) {
                scannedPackages.put(packageName, System.currentTimeMillis());
                Thread thread = new Thread(() -> scanViews(event.getSource()));
                scannerThreads.put(packageName, thread);
                thread.start();
            }
        }
    }

    @Override
    public void onInterrupt() {
    }

    private void scanViews(AccessibilityNodeInfo mNodeInfo) {
        try {
            //May already be gone
            if (mNodeInfo == null) {
                return;
            }

            //Get and check the text
            String text = (String) mNodeInfo.getText();
            if (text != null && text.contains(".") && text.length() < 10000) {
                //Don't scan text if we already did
                int hashDomain = mNodeInfo.getText().hashCode();
                if (scannedText.contains(hashDomain)) {
                    return;
                } else {
                    if (scannedText.size() > 10000) {
                        scannedText.clear();
                    }
                    scannedText.add(hashDomain);
                    scanText(text.toLowerCase());
                }
            }

            //Finish if no more children
            if (mNodeInfo.getChildCount() < 1) {
                return;
            }

            //Recurse into the children otherwise
            for (int i = 0; i < mNodeInfo.getChildCount(); i++) {
                scanViews(mNodeInfo.getChild(i));
            }
        } catch (Exception ignored) {
        }
    }

    private void scanText(String haystack) {
        Matcher matcher = hostnamePattern.matcher(haystack);
        while (matcher.find()) {
            scanDomain(matcher.group());
        }
        if (haystack.contains("/")) {
            for (String split : haystack.split("/")) {
                scanText(split);
            }
        }
    }

    private void scanDomain(String domain) {
        //Don't scan domain if we already did
        if (!scannedDomains.contains(domain)) {
            if (scannedDomains.size() > 1000) {
                scannedDomains.clear();
            }
            scannedDomains.add(domain);
            if (Database.domains.mightContain(domain)) {
                sendNotification(domain);
            }
        }
    }

    private void sendNotification(String link) {
        link = link.replaceAll("\\.", "[.]");
        Notification.Builder mBuilder =
                new Notification.Builder(this)
                        .setSmallIcon(R.drawable.ic_notification)
                        .setContentTitle(getText(R.string.lblNotificationLinkDetection))
                        .setContentText("Domain: >>>" + link + "<<<")
                        .setStyle(new Notification.BigTextStyle().bigText("Domain: >>>" + link + "<<<"))
                        .setPriority(Notification.PRIORITY_MAX)
                        .setDefaults(Notification.DEFAULT_VIBRATE);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            mBuilder.setVisibility(Notification.VISIBILITY_SECRET);
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            mBuilder.setChannelId("DETECTION");
        }
        notificationManager.notify(new Random().nextInt(), mBuilder.build());
    }

}
